# Binary Exploitation

### Assembly Language (Basics)

Practice on : https://microcorruption.com/debugger/New%20Orleans

Read basic instructions in assembly like :

- compare
- jump
- add
- move
- subtract
- goto
- push
- pop

.... etc.

Focus on Memory and Stack instructions

### Cracking a Binary

Github Link : https://github.com/LiveOverflow/liveoverflow_youtube/tree/master/0x05_simple_crackme_intro_assembler

Download the resources

```bash
wget https://raw.githubusercontent.com/LiveOverflow/liveoverflow_youtube/master/0x05_simple_crackme_intro_assembler/gdb_disassembly
wget https://raw.githubusercontent.com/LiveOverflow/liveoverflow_youtube/master/0x05_simple_crackme_intro_assembler/license_1.c

### After getting compile the binary

gcc license_1.c -o license
```

It's a simple program which checks if a license is valid or not by taking a input as an argument.
To see binary assembly code 
```bash
gdb "binary_name"
```

Always set the view as : set disassembly-flavor intel
To disassemble a function : disassemble "func_name"


Analyse the assembly Code -> :)

**GDB Commands :**

- break (star)"point_where_to_break" : Eg, break *main
- info registers : To get the info about the basic memory layout
- si : to go through the code by instruction wise and stopping each time
- ni : to go through the code by executing the function first and then stopping on the first instruction
- run / run "args" : to start the program 
- set "memory_pointer" : Eg, set $eax=0, This will set the eax pointer to 0

**Tools :**

- radare2
- Hopper Disassembler
- strings
- objdump
- hexdump

**Radare 2 Commands :**

```bash
r2 binary_name
```

- aaa : to analyse all the functions
- afl : to analyse and list the functions
- ? : to get the help menu for commands
- pdf : to display the disassembled code of a function
- s "func/point" : this will set the address to what we are giving as input to point. Eg, s sym.main
- VV : To get graphical view / control graph


### Let's try to make our code more safe 

Step 1 : let's not store the string as it is in the code
Step 2 : Compare the sum of ascii's of the input with the sum of the real key

Now our program is :

```C
#include <string.h>
#include <stdio.h>

int main(int argc, char *argv[]) {
        if(argc==2) {
                printf("Checking License: %s\n", argv[1]);
                int sum = 0;
                for(int i = 0; i < strlen(argv[1]);i++){
                        sum += (int)argv[1][i];
                }
                if(sum == 916) {
                        printf("Access Granted!\n");
                } else {
                        printf("WRONG!\n");
                }
        } else {
                printf("Usage: <key>\n");
        }
        return 0;
}

```

Using Radare 2 analyse the compiled binary and getting the way to bypass checks.
Now making safe doesn't work so now we move to a new approach which is :

**USING A PARSER DIFFERENTIAL**

What is this and what it will do ?

-> Now as we know that we can run the binary in linux system and we can also pass it through gdb and radare2 to analyse but what if we can do something so that we will still be able to
run the binary but we aren't able to pass it through GDB and radare like softwares


Let's write a python script for achieving our goal.
**fuzzer.py** in 0x08 folder

Uses :
- We can use this fuzzing technique to hide the working of our malware and stop people from analysing it.
- To make the code uncrackable

The script above is not written in professional way but it gives us a glimpse of how the **Parser Differential** works.

More on this topic

- https://www.sentinelone.com/blog/breaking-and-evading/
- https://ioactive.com/striking-back-gdb-and-ida-debuggers/
